---
# Source: keycloak/charts/keycloak/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: keycloak
  namespace: default
  labels:
    app.kubernetes.io/name: keycloak
    helm.sh/chart: keycloak-8.0.0
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: keycloak
automountServiceAccountToken: true
---
# Source: keycloak/charts/keycloak/charts/postgresql/templates/secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: keycloak-postgresql
  namespace: "default"
  labels:
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-11.1.28
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/managed-by: Helm
type: Opaque
data:
  postgres-password: "M1FaVmR5OFdLRw=="
  password: "c2VjcmV0cGFzc3dvcmQ="
  replication-password: "c2VjcmV0cmVwbGljYXRpb25wYXNzd29yZA=="
  # We don't auto-generate LDAP password when it's not provided as we do for other passwords
---
# Source: keycloak/charts/keycloak/templates/secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: keycloak
  namespace: default
  labels:
    app.kubernetes.io/name: keycloak
    helm.sh/chart: keycloak-8.0.0
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: keycloak
type: Opaque
data:
  admin-password: "Zml3YXJlQWRtaW4="
  management-password: "aXlUYWxrMmhaNw=="
---
# Source: keycloak/charts/keycloak/templates/configmap-env-vars.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: keycloak-env-vars
  namespace: default
  labels:
    app.kubernetes.io/name: keycloak
    helm.sh/chart: keycloak-8.0.0
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: keycloak
data:
  KEYCLOAK_CREATE_ADMIN_USER: "true"
  KEYCLOAK_ADMIN_USER: "fiwareAdmin"
  KEYCLOAK_MANAGEMENT_USER: "manager"
  KEYCLOAK_HTTP_PORT: "8080"
  KEYCLOAK_PROXY: passthrough
  KEYCLOAK_ENABLE_STATISTICS: "false"
  KEYCLOAK_DATABASE_HOST: "keycloak-postgresql-primary"
  KEYCLOAK_DATABASE_PORT: "5432"
  KEYCLOAK_DATABASE_NAME: "bitnami_keycloak"
  KEYCLOAK_DATABASE_USER: "bn_keycloak"
  KEYCLOAK_ENABLE_TLS: "false"
---
# Source: keycloak/templates/profilesConfigMap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: keycloak-profile
data:
  profile.properties: |-
    feature.scripts=enabled
    feature.upload_scripts=enabled
---
# Source: keycloak/templates/realmConfigmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: keycloak-realm
data:
  realm.json: |-
    {
      "id": "fiware-server",
      "realm": "fiware-server",
      "displayName": "Keycloak",
      "displayNameHtml": "<div class=\"kc-logo-text\"><span>Keycloak</span></div>",
      "enabled": true,
      "attributes": {
        "frontendUrl": "http://keycloak:80"
      },
      "sslRequired": "none",
      "roles": {
        "realm": [
          {
            "name": "user",
            "description": "User privileges",
            "composite": false,
            "clientRole": false,
            "containerId": "fiware-server",
            "attributes": {}
          }
        ],
        "client": {
          "orion-pep": [
            {
              "name": "admin",
              "description": "A",
              "composite": false,
              "clientRole": true
            },
            {
              "name": "uma_protection",
              "composite": false,
              "clientRole": true
            },
            {
              "name": "producer",
              "composite": false,
              "clientRole": true
            },
            {
              "name": "subscriptor",
              "composite": false,
              "clientRole": true
            },
            {
              "name": "consumer",
              "composite": false,
              "clientRole": true
            }
          ],
          "fiware-login": [],
          "grafana": [
            {
              "name": "Admin",
              "composite": false,
              "clientRole": true
            },
            {
              "name": "Viewer",
              "composite": false,
              "clientRole": true
            },
            {
              "name": "Editor",
              "composite": false,
              "clientRole": true
            }
          ]
        }
      },
      "groups": [
        {
          "name": "admin",
          "path": "/admin",
          "realmRoles": [
            "user"
          ],
          "clientRoles": {
            "orion-pep": [
              "admin"
            ]
          }
        },
        {
          "name": "grafana-admin",
          "path": "/grafana-admin",
          "clientRoles": {
            "grafana": [
              "Admin"
            ]
          }
        },
        {
          "name": "e2e-test",
          "path": "/e2e-test",
          "realmRoles": [
            "user"
          ],
          "attributes": {
            "fiware-service": [
              ""
            ],
            "fiware-servicepath": [
              "/"
            ]
          },
          "clientRoles": {
            "orion-pep": [
              "admin",
              "producer",
              "subscriptor",
              "consumer"
            ]
          }
        },
        {
          "name": "grafana-editor",
          "path": "/grafana-editor",
          "clientRoles": {
            "grafana": [
              "Editor"
            ]
          }
        },
        {
          "name": "grafana-viewer",
          "path": "/grafana-viewer",
          "clientRoles": {
            "grafana": [
              "Viewer"
            ]
          }
        },
        {
          "name": "test-test",
          "path": "/test-test",
          "attributes": {
            "fiware-service": [
              "Test"
            ],
            "fiware-servicepath": [
              "/test"
            ]
          },
          "realmRoles": [
            "user"
          ],
          "subGroups": [
            {
              "name": "test-test-subscriptor",
              "path": "/test-test/test-test-subscriptor",
              "clientRoles": {
                "orion-pep": [
                  "subscriptor"
                ]
              }
            },
            {
              "name": "test-test-consumer",
              "path": "/test-test/test-test-consumer",
              "clientRoles": {
                "orion-pep": [
                  "consumer"
                ]
              }
            },
            {
              "name": "test-test-producer",
              "path": "/test-test/test-test-producer",
              "clientRoles": {
                "orion-pep": [
                  "producer"
                ]
              }
            }
          ]
        },
        {
          "name": "airquality-data",
          "path": "/airquality-data",
          "attributes": {
            "fiware-service": [
              "AirQuality"
            ],
            "fiware-servicepath": [
              "/data"
            ]
          },
          "realmRoles": [
            "user"
          ],
          "subGroups": [
            {
              "name": "airquality-data-subscriptor",
              "path": "/airquality-data/airquality-data-subscriptor",
              "clientRoles": {
                "orion-pep": [
                  "subscriptor"
                ]
              }
            },
            {
              "name": "airquality-data-consumer",
              "path": "/airquality-data/airquality-data-consumer",
              "clientRoles": {
                "orion-pep": [
                  "consumer"
                ]
              }
            },
            {
              "name": "airquality-data-producer",
              "path": "/airquality-data/airquality-data-producer",
              "clientRoles": {
                "orion-pep": [
                  "producer"
                ]
              }
            }
          ]
        }
      ],
      "users": [
        {
          "username": "admin-user",
          "enabled": true,
          "email": "admin-user@hopu.eu",
          "credentials": [
            {
              "type": "password",
              "value": "admin-user"
            }
          ],
          "clientRoles": {
            "account": [
              "view-profile",
              "manage-account"
            ]
          },
          "groups": [
            "/admin",
            "/grafana-admin"
          ]
        },
        {
          "username": "consumer-user",
          "enabled": true,
          "credentials": [
            {
              "type": "password",
              "value": "consumer-user"
            }
          ],
          "disableableCredentialTypes": [
            "password"
          ],
          "requiredActions": [],
          "clientRoles": {
            "account": [
              "view-profile",
              "manage-account"
            ]
          },
          "notBefore": 0,
          "groups": [
            "/test-test/test-test-consumer"
          ]
        },
        {
          "username": "producer-user",
          "enabled": true,
          "credentials": [
            {
              "type": "password",
              "value": "producer-user"
            }
          ],
          "clientRoles": {
            "account": [
              "view-profile",
              "manage-account"
            ]
          },
          "groups": [
            "/test-test/test-test-producer"
          ]
        },
        {
          "username": "subscriptor-user",
          "enabled": true,
          "credentials": [
            {
              "type": "password",
              "value": "subscriptor-user"
            }
          ],
          "clientRoles": {
            "account": [
              "view-profile",
              "manage-account"
            ]
          },
          "groups": [
            "/test-test/test-test-subscriptor"
          ]
        },
        {
          "username": "airquality-producer",
          "enabled": true,
          "credentials": [
            {
              "type": "password",
              "value": "airquality-producer"
            }
          ],
          "clientRoles": {
            "account": [
              "view-profile",
              "manage-account"
            ]
          },
          "groups": [
            "/airquality-data/airquality-data-producer"
          ]
        }
      ],
      "clients": [
        {
          "clientId": "fiware-login",
          "surrogateAuthRequired": false,
          "enabled": true,
          "clientAuthenticatorType": "client-secret",
          "secret": "da756bc9-b059-4e0e-be39-93f49e4df999",
          "redirectUris": [],
          "webOrigins": [],
          "notBefore": 0,
          "bearerOnly": false,
          "consentRequired": false,
          "standardFlowEnabled": true,
          "implicitFlowEnabled": false,
          "directAccessGrantsEnabled": true,
          "serviceAccountsEnabled": false,
          "publicClient": true,
          "frontchannelLogout": false,
          "protocol": "openid-connect",
          "attributes": {},
          "authenticationFlowBindingOverrides": {},
          "fullScopeAllowed": true,
          "nodeReRegistrationTimeout": -1
        },
        {
          "clientId": "grafana",
          "rootUrl": "https://grafana",
          "adminUrl": "https://grafana",
          "surrogateAuthRequired": false,
          "enabled": true,
          "clientAuthenticatorType": "client-secret",
          "secret": "secret",
          "redirectUris":             [
              "https://grafana/",
              "https://grafana-2/"
            ],
          "webOrigins":             [
              "https://grafana/",
              "https://grafana-2/"
            ],
          "notBefore": 0,
          "bearerOnly": false,
          "consentRequired": false,
          "standardFlowEnabled": true,
          "implicitFlowEnabled": false,
          "directAccessGrantsEnabled": true,
          "serviceAccountsEnabled": false,
          "publicClient": false,
          "frontchannelLogout": false,
          "protocol": "openid-connect",
          "authenticationFlowBindingOverrides": {},
          "fullScopeAllowed": true,
          "nodeReRegistrationTimeout": -1
        },
        {
          "clientId": "orion-pep",
          "adminUrl": "https://orion-ld",
          "baseUrl": "https://orion-ld",
          "surrogateAuthRequired": false,
          "enabled": true,
          "clientAuthenticatorType": "client-secret",
          "secret": "978ad148-d99b-406d-83fc-578597290a79",
          "redirectUris":             [
              "https://orion-ld/",
              "https://orion-ld-2/"
            ],
          "webOrigins":             [
              "https://orion-ld/",
              "https://orion-ld-2/"
            ],
          "notBefore": 0,
          "bearerOnly": false,
          "consentRequired": false,
          "standardFlowEnabled": true,
          "implicitFlowEnabled": false,
          "directAccessGrantsEnabled": true,
          "serviceAccountsEnabled": true,
          "authorizationServicesEnabled": true,
          "publicClient": false,
          "frontchannelLogout": false,
          "protocol": "openid-connect",
          "authenticationFlowBindingOverrides": {},
          "fullScopeAllowed": true,
          "nodeReRegistrationTimeout": -1,
          "authorizationSettings": {
            "allowRemoteResourceManagement": true,
            "policyEnforcementMode": "ENFORCING",
            "resources": [
              {
                "name": "v1",
                "type": "orion:context-management",
                "ownerManagedAccess": false,
                "displayName": "Context management v1 API",
                "uris": [
                  "/v1/*"
                ]
              },
              {
                "name": "v2",
                "type": "orion:context-management",
                "ownerManagedAccess": false,
                "displayName": "Context management v2 API",
                "uris": [
                  "/v2/*"
                ]
              },
              {
                "name": "version",
                "type": "orion:admin",
                "ownerManagedAccess": false,
                "displayName": "List version",
                "uris": [
                  "/version"
                ]
              },
              {
                "name": "admin",
                "type": "orion:admin",
                "ownerManagedAccess": false,
                "displayName": "Admin API",
                "uris": [
                  "/admin/*"
                ]
              },
              {
                "name": "subscriptions",
                "type": "orion:subscriptions",
                "ownerManagedAccess": false,
                "uris": [
                  "/v2/subscriptions",
                  "/v2/subscriptions/*"
                ]
              }
            ],
            "policies": [
              {
                "name": "fiware-headers context management v3",
                "description": "",
                "type": "js",
                "logic": "POSITIVE",
                "decisionStrategy": "UNANIMOUS",
                "config": {
                  "code": "var context = $evaluation.getContext();\nvar attributes = context.getAttributes();\nvar identity = context.getIdentity();\n \nif (attributes.exists('http.fiware-service') && \n    attributes.exists('http.fiware-servicepath') && \n    attributes.exists('http.method') && \n    identity.getAttributes().exists('fiware-scope-object')) {\n\n    var request_service = attributes.getValue('http.fiware-service').asString(0);\n    var request_servicepath = attributes.getValue('http.fiware-servicepath').asString(0);\n    var request_method = attributes.getValue('http.method').asString(0);\n    \n    var fiware_scopes = identity.getAttributes().getValue('fiware-scope-object');\n    var fiware_scope;\n\n    var index;\n    for (index = 0; index < fiware_scopes.size(); index++) {\n        fiware_scope = JSON.parse(fiware_scopes.asString(index));\n\n        if (fiware_scope.hasOwnProperty(\"fiware-service\") &&\n            fiware_scope[\"fiware-service\"] === request_service && \n            fiware_scope.hasOwnProperty(\"fiware-servicepath\") &&\n            fiware_scope[\"fiware-servicepath\"].equals(request_servicepath) && \n            fiware_scope.hasOwnProperty(\"orion-roles\") &&\n            ((fiware_scope[\"orion-roles\"].equals('consumer') && request_method === 'GET') ||\n             (fiware_scope[\"orion-roles\"].equals('producer') && ['POST', 'PUT', 'PATCH', 'DELETE'].indexOf(request_method) != -1))\n            ) {\n                $evaluation.grant();\n        }            \n    }\n}"
                }
              },
              {
                "name": "consumer method",
                "description": "Comprueba que el método de la petición es el permitido para un consumer (GET)",
                "type": "js",
                "logic": "POSITIVE",
                "decisionStrategy": "UNANIMOUS",
                "config": {
                  "code": "var context = $evaluation.getContext();\nvar attributes = context.getAttributes();\nvar identity = context.getIdentity();\n \nvar method = attributes.getValue('http.method').asString(0);\n\nif (method === 'GET') {\n    $evaluation.grant();\n}\n"
                }
              },
              {
                "name": "consumer user",
                "description": "Comprueba que el usuario tiene rol consumer",
                "type": "role",
                "logic": "POSITIVE",
                "decisionStrategy": "UNANIMOUS",
                "config": {
                  "roles": "[{\"id\":\"orion-pep/consumer\",\"required\":true}]"
                }
              },

              {
                "name": "consumer policy v3",
                "type": "aggregate",
                "logic": "POSITIVE",
                "decisionStrategy": "UNANIMOUS",
                "config": {
                  "applyPolicies": "[\"fiware-headers context management v3\",\"consumer method\",\"consumer user\"]"
                }
              },

              {
                "name": "producer user",
                "description": "Comprueba que el usuario tiene rol producer",
                "type": "role",
                "logic": "POSITIVE",
                "decisionStrategy": "UNANIMOUS",
                "config": {
                  "roles": "[{\"id\":\"orion-pep/producer\",\"required\":true}]"
                }
              },
              {
                "name": "producer method",
                "description": "Comprueba que el método de la petición es el permitido para un producer (POST, PUT, PATCH o DELETE)",
                "type": "js",
                "logic": "POSITIVE",
                "decisionStrategy": "UNANIMOUS",
                "config": {
                  "code": "var context = $evaluation.getContext();\nvar attributes = context.getAttributes();\nvar identity = context.getIdentity();\n \nvar method = attributes.getValue('http.method').asString(0);\n\nif (method === 'POST' || method === 'PUT' || method === 'PATCH' || method === 'DELETE') {\n    $evaluation.grant();\n}\n"
                }
              },
              {
                "name": "producer policy v3",
                "type": "aggregate",
                "logic": "POSITIVE",
                "decisionStrategy": "UNANIMOUS",
                "config": {
                  "applyPolicies": "[\"producer user\",\"fiware-headers context management v3\",\"producer method\"]"
                }
              },

              {
                "name": "admin user",
                "description": "Comprueba que el usuario tiene rol admin",
                "type": "role",
                "logic": "POSITIVE",
                "decisionStrategy": "UNANIMOUS",
                "config": {
                  "roles": "[{\"id\":\"orion-pep/admin\",\"required\":true}]"
                }
              },

              {
                "name": "fiware-headers subscriptions v3",
                "type": "js",
                "logic": "POSITIVE",
                "decisionStrategy": "UNANIMOUS",
                "config": {
                  "code": "var context = $evaluation.getContext();\nvar attributes = context.getAttributes();\nvar identity = context.getIdentity();\n \nif (attributes.exists('http.fiware-service') && \n    attributes.exists('http.fiware-servicepath') && \n    attributes.exists('http.method') && \n    identity.getAttributes().exists('fiware-scope-object')) {\n\n    var request_service = attributes.getValue('http.fiware-service').asString(0);\n    var request_servicepath = attributes.getValue('http.fiware-servicepath').asString(0);\n    var request_method = attributes.getValue('http.method').asString(0);\n    \n    var fiware_scopes = identity.getAttributes().getValue('fiware-scope-object');\n    var fiware_scope;\n\n    var index;\n    for (index = 0; index < fiware_scopes.size(); index++) {\n        fiware_scope = JSON.parse(fiware_scopes.asString(index));\n\n        if (fiware_scope.hasOwnProperty(\"fiware-service\") &&\n            fiware_scope[\"fiware-service\"] === request_service && \n            fiware_scope.hasOwnProperty(\"fiware-servicepath\") &&\n            fiware_scope[\"fiware-servicepath\"].contains(request_servicepath) && \n            fiware_scope.hasOwnProperty(\"orion-roles\") &&\n            (fiware_scope[\"orion-roles\"].contains('subscriptor') && ['GET','POST', 'PUT', 'PATCH', 'DELETE'].indexOf(request_method) != -1)) {\n            $evaluation.grant();\n        }            \n    }\n}"
                }
              },

              {
                "name": "subscriptor user",
                "description": "Comprueba que el usuario tiene el rol subscriptor",
                "type": "role",
                "logic": "POSITIVE",
                "decisionStrategy": "UNANIMOUS",
                "config": {
                  "roles": "[{\"id\":\"orion-pep/subscriptor\",\"required\":true}]"
                }
              },
              {
                "name": "subscriptor policy v3",
                "type": "aggregate",
                "logic": "POSITIVE",
                "decisionStrategy": "UNANIMOUS",
                "config": {
                  "applyPolicies": "[\"fiware-headers subscriptions v3\",\"subscriptor user\"]"
                }
              },

              {
                "name": "context management resources",
                "description": "Para acceder a la api de context management (/v1 o /v2) el usuario debe ser admin o consumer o producer",
                "type": "resource",
                "logic": "POSITIVE",
                "decisionStrategy": "AFFIRMATIVE",
                "config": {
                  "defaultResourceType": "orion:context-management",
                  "applyPolicies": "[\"producer policy v3\",\"consumer policy v3\",\"admin user\"]"
                }
              },
              {
                "name": "admin resources",
                "description": "Sólo los usuarios admin pueden acceder a los recursos orion:admin (/version y /admin)",
                "type": "resource",
                "logic": "POSITIVE",
                "decisionStrategy": "UNANIMOUS",
                "config": {
                  "defaultResourceType": "orion:admin",
                  "applyPolicies": "[\"admin user\"]"
                }
              },
              {
                "name": "subscriptions",
                "description": "Para acceder a la api de subscription el usuario debe ser subscriptor",
                "type": "resource",
                "logic": "POSITIVE",
                "decisionStrategy": "AFFIRMATIVE",
                "config": {
                  "resources": "[\"subscriptions\"]",
                  "applyPolicies": "[\"subscriptor policy v3\",\"admin user\"]"
                }
              }
            ],
            "scopes": []
          },
          "defaultClientScopes": [
            "web-origins",
            "profile",
            "roles",
            "fiware-scope",
            "email"
          ],
          "optionalClientScopes": [
            "address",
            "phone",
            "offline_access",
            "microprofile-jwt"
          ]
        }
      ],
      "clientScopes": [
        {
          "name": "fiware-scope",
          "protocol": "openid-connect",
          "attributes": {
            "include.in.token.scope": "true",
            "display.on.consent.screen": "false"
          },
          "protocolMappers": [
            {
              "name": "fiware-scope-object",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-script-based-protocol-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "multivalued": "true",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "fiware-scope-object",
                "script": "/**\n * Available variables: \n * user - the current user\n * realm - the current realm\n * token - the current token\n * userSession - the current userSession\n * keycloakSession - the current userSession\n */\n\nvar ArrayList = Java.type(\"java.util.ArrayList\");\nvar fiware_scope = new ArrayList();\n\nvar forEach = Array.prototype.forEach;\n\nvar fiware_service;\nvar fiware_servicepath;\nvar fiware_entry;\nvar roles = '';\n\nvar orion_client = realm.getClientByClientId('orion-pep');\n\nfiware_service = user.getFirstAttribute('fiware-service');\nfiware_servicepath = user.getFirstAttribute('fiware-servicepath');\nif (fiware_service !== null && fiware_servicepath !== null) {\n\n    fiware_entry = {\n        \"fiware-service\": fiware_service,\n        \"fiware-servicepath\": fiware_servicepath\n    };\n\n    var roleModels = user.getClientRoleMappings(orion_client);\n    if (roleModels.size() > 0) {\n        forEach.call(\n            user.getClientRoleMappings(orion_client).toArray(),\n            function (role) {\n                roles = roles + role.getName() + \",\";\n            }\n        );\n        roles = roles.substring(0, roles.length - 1);\n        fiware_entry[\"orion-roles\"] = roles;\n        roles = '';\n    }\n\n    fiware_scope.add(JSON.stringify(fiware_entry));\n    fiware_entry = {};\n}\n\nforEach.call(\n    user.getGroups().toArray(),\n    function (group) {\n\n        fiware_service = group.getFirstAttribute('fiware-service');\n        fiware_servicepath = group.getFirstAttribute('fiware-servicepath');\n        if (fiware_service !== null && fiware_servicepath !== null) {\n            fiware_entry = {\n                \"fiware-service\": fiware_service,\n                \"fiware-servicepath\": fiware_servicepath\n            };\n\n            var roleModels = group.getClientRoleMappings(orion_client);\n            if (roleModels.size() > 0) {\n                forEach.call(\n                    group.getClientRoleMappings(orion_client).toArray(),\n                    function (role) {\n                        roles = roles + role.getName() + \",\";\n                    }\n                );\n                roles = roles.substring(0, roles.length - 1);\n                fiware_entry[\"orion-roles\"] = roles;\n                roles = '';\n            }\n\n            fiware_scope.add(JSON.stringify(fiware_entry));\n            fiware_entry = {};\n        } else if (group.getParentId() !== null) {\n            fiware_service = group.getParent().getFirstAttribute('fiware-service');\n            fiware_servicepath = group.getParent().getFirstAttribute('fiware-servicepath');\n\n            if (fiware_service !== null && fiware_servicepath !== null) {\n                fiware_entry = {\n                    \"fiware-service\": fiware_service,\n                    \"fiware-servicepath\": fiware_servicepath\n                };\n                var subroleModels = group.getClientRoleMappings(orion_client);\n                if (subroleModels.size() > 0) {\n                    forEach.call(\n                        group.getClientRoleMappings(orion_client).toArray(),\n                        function (role) {\n                            roles = roles + role.getName() + \",\";\n                        }\n                    );\n                    roles = roles.substring(0, roles.length - 1);\n                    fiware_entry[\"orion-roles\"] = roles;\n                    roles = '';\n                }\n\n                fiware_scope.add(JSON.stringify(fiware_entry));\n                fiware_entry = '';\n            }\n        }\n    }\n);\n\nexports = fiware_scope;"
              }
            }
          ]
        },
        {
          "name": "offline_access",
          "description": "OpenID Connect built-in scope: offline_access",
          "protocol": "openid-connect",
          "attributes": {
            "consent.screen.text": "${offlineAccessScopeConsentText}",
            "display.on.consent.screen": "true"
          }
        },
        {
          "name": "microprofile-jwt",
          "description": "Microprofile - JWT built-in scope",
          "protocol": "openid-connect",
          "attributes": {
            "include.in.token.scope": "true",
            "display.on.consent.screen": "false"
          },
          "protocolMappers": [
            {
              "name": "upn",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-property-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "user.attribute": "username",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "upn",
                "jsonType.label": "String"
              }
            },
            {
              "name": "groups",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-realm-role-mapper",
              "consentRequired": false,
              "config": {
                "multivalued": "true",
                "user.attribute": "foo",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "groups",
                "jsonType.label": "String"
              }
            }
          ]
        },
        {
          "name": "roles",
          "description": "OpenID Connect scope for add user roles to the access token",
          "protocol": "openid-connect",
          "attributes": {
            "include.in.token.scope": "false",
            "display.on.consent.screen": "true",
            "consent.screen.text": "${rolesScopeConsentText}"
          },
          "protocolMappers": [
            {
              "name": "audience resolve",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-audience-resolve-mapper",
              "consentRequired": false,
              "config": {}
            },
            {
              "name": "client roles",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-client-role-mapper",
              "consentRequired": false,
              "config": {
                "user.attribute": "foo",
                "access.token.claim": "true",
                "claim.name": "resource_access.${client_id}.roles",
                "jsonType.label": "String",
                "multivalued": "true"
              }
            },
            {
              "name": "realm roles",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-realm-role-mapper",
              "consentRequired": false,
              "config": {
                "user.attribute": "foo",
                "access.token.claim": "true",
                "claim.name": "realm_access.roles",
                "jsonType.label": "String",
                "multivalued": "true"
              }
            }
          ]
        },
        {
          "name": "email",
          "description": "OpenID Connect built-in scope: email",
          "protocol": "openid-connect",
          "attributes": {
            "include.in.token.scope": "true",
            "display.on.consent.screen": "true",
            "consent.screen.text": "${emailScopeConsentText}"
          },
          "protocolMappers": [
            {
              "name": "email",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-property-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "user.attribute": "email",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "email",
                "jsonType.label": "String"
              }
            },
            {
              "name": "email verified",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-property-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "user.attribute": "emailVerified",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "email_verified",
                "jsonType.label": "boolean"
              }
            }
          ]
        },
        {
          "name": "phone",
          "description": "OpenID Connect built-in scope: phone",
          "protocol": "openid-connect",
          "attributes": {
            "include.in.token.scope": "true",
            "display.on.consent.screen": "true",
            "consent.screen.text": "${phoneScopeConsentText}"
          },
          "protocolMappers": [
            {
              "name": "phone number verified",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-attribute-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "user.attribute": "phoneNumberVerified",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "phone_number_verified",
                "jsonType.label": "boolean"
              }
            },
            {
              "name": "phone number",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-attribute-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "user.attribute": "phoneNumber",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "phone_number",
                "jsonType.label": "String"
              }
            }
          ]
        },
        {
          "name": "address",
          "description": "OpenID Connect built-in scope: address",
          "protocol": "openid-connect",
          "attributes": {
            "include.in.token.scope": "true",
            "display.on.consent.screen": "true",
            "consent.screen.text": "${addressScopeConsentText}"
          },
          "protocolMappers": [
            {
              "name": "address",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-address-mapper",
              "consentRequired": false,
              "config": {
                "user.attribute.formatted": "formatted",
                "user.attribute.country": "country",
                "user.attribute.postal_code": "postal_code",
                "userinfo.token.claim": "true",
                "user.attribute.street": "street",
                "id.token.claim": "true",
                "user.attribute.region": "region",
                "access.token.claim": "true",
                "user.attribute.locality": "locality"
              }
            }
          ]
        },
        {
          "name": "role_list",
          "description": "SAML role list",
          "protocol": "saml",
          "attributes": {
            "consent.screen.text": "${samlRoleListScopeConsentText}",
            "display.on.consent.screen": "true"
          },
          "protocolMappers": [
            {
              "name": "role list",
              "protocol": "saml",
              "protocolMapper": "saml-role-list-mapper",
              "consentRequired": false,
              "config": {
                "single": "false",
                "attribute.nameformat": "Basic",
                "attribute.name": "Role"
              }
            }
          ]
        },
        {
          "name": "profile",
          "description": "OpenID Connect built-in scope: profile",
          "protocol": "openid-connect",
          "attributes": {
            "include.in.token.scope": "true",
            "display.on.consent.screen": "true",
            "consent.screen.text": "${profileScopeConsentText}"
          },
          "protocolMappers": [
            {
              "name": "zoneinfo",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-attribute-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "user.attribute": "zoneinfo",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "zoneinfo",
                "jsonType.label": "String"
              }
            },
            {
              "name": "nickname",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-attribute-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "user.attribute": "nickname",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "nickname",
                "jsonType.label": "String"
              }
            },
            {
              "name": "profile",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-attribute-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "user.attribute": "profile",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "profile",
                "jsonType.label": "String"
              }
            },
            {
              "name": "full name",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-full-name-mapper",
              "consentRequired": false,
              "config": {
                "id.token.claim": "true",
                "access.token.claim": "true",
                "userinfo.token.claim": "true"
              }
            },
            {
              "name": "birthdate",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-attribute-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "user.attribute": "birthdate",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "birthdate",
                "jsonType.label": "String"
              }
            },
            {
              "name": "family name",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-property-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "user.attribute": "lastName",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "family_name",
                "jsonType.label": "String"
              }
            },
            {
              "name": "picture",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-attribute-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "user.attribute": "picture",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "picture",
                "jsonType.label": "String"
              }
            },
            {
              "name": "website",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-attribute-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "user.attribute": "website",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "website",
                "jsonType.label": "String"
              }
            },
            {
              "name": "locale",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-attribute-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "user.attribute": "locale",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "locale",
                "jsonType.label": "String"
              }
            },
            {
              "name": "username",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-property-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "user.attribute": "username",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "preferred_username",
                "jsonType.label": "String"
              }
            },
            {
              "name": "given name",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-property-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "user.attribute": "firstName",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "given_name",
                "jsonType.label": "String"
              }
            },
            {
              "name": "updated at",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-attribute-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "user.attribute": "updatedAt",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "updated_at",
                "jsonType.label": "String"
              }
            },
            {
              "name": "middle name",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-attribute-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "user.attribute": "middleName",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "middle_name",
                "jsonType.label": "String"
              }
            },
            {
              "name": "gender",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-usermodel-attribute-mapper",
              "consentRequired": false,
              "config": {
                "userinfo.token.claim": "true",
                "user.attribute": "gender",
                "id.token.claim": "true",
                "access.token.claim": "true",
                "claim.name": "gender",
                "jsonType.label": "String"
              }
            }
          ]
        },
        {
          "name": "web-origins",
          "description": "OpenID Connect scope for add allowed web origins to the access token",
          "protocol": "openid-connect",
          "attributes": {
            "include.in.token.scope": "false",
            "display.on.consent.screen": "false",
            "consent.screen.text": ""
          },
          "protocolMappers": [
            {
              "name": "allowed web origins",
              "protocol": "openid-connect",
              "protocolMapper": "oidc-allowed-origins-mapper",
              "consentRequired": false,
              "config": {}
            }
          ]
        }
      ],
      "defaultDefaultClientScopes": [
        "roles",
        "role_list",
        "email",
        "web-origins",
        "profile"
      ],
      "defaultOptionalClientScopes": [
        "microprofile-jwt",
        "phone",
        "address",
        "offline_access"
      ]
    }
---
# Source: keycloak/charts/keycloak/charts/postgresql/templates/primary/svc-headless.yaml
apiVersion: v1
kind: Service
metadata:
  name: keycloak-postgresql-primary-hl
  namespace: "default"
  labels:
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-11.1.28
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: primary
    # Use this annotation in addition to the actual publishNotReadyAddresses
    # field below because the annotation will stop being respected soon but the
    # field is broken in some versions of Kubernetes:
    # https://github.com/kubernetes/kubernetes/issues/58662
    service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
spec:
  type: ClusterIP
  clusterIP: None
  # We want all pods in the StatefulSet to have their addresses published for
  # the sake of the other Postgresql pods even before they're ready, since they
  # have to be able to talk to each other in order to become ready.
  publishNotReadyAddresses: true
  ports:
    - name: tcp-postgresql
      port: 5432
      targetPort: tcp-postgresql
  selector:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/component: primary
---
# Source: keycloak/charts/keycloak/charts/postgresql/templates/primary/svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: keycloak-postgresql-primary
  namespace: "default"
  labels:
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-11.1.28
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: primary
  annotations:
spec:
  type: ClusterIP
  ports:
    - name: tcp-postgresql
      port: 5432
      targetPort: tcp-postgresql
      nodePort: null
  selector:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/component: primary
---
# Source: keycloak/charts/keycloak/charts/postgresql/templates/read/svc-headless.yaml
apiVersion: v1
kind: Service
metadata:
  name: keycloak-postgresql-read-hl
  namespace: "default"
  labels:
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-11.1.28
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: read
    # Use this annotation in addition to the actual publishNotReadyAddresses
    # field below because the annotation will stop being respected soon but the
    # field is broken in some versions of Kubernetes:
    # https://github.com/kubernetes/kubernetes/issues/58662
    service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
spec:
  type: ClusterIP
  clusterIP: None
  # We want all pods in the StatefulSet to have their addresses published for
  # the sake of the other Postgresql pods even before they're ready, since they
  # have to be able to talk to each other in order to become ready.
  publishNotReadyAddresses: true
  ports:
    - name: tcp-postgresql
      port: 5432
      targetPort: tcp-postgresql
  selector:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/component: read
---
# Source: keycloak/charts/keycloak/charts/postgresql/templates/read/svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: keycloak-postgresql-read
  namespace: "default"
  labels:
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-11.1.28
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: read
  annotations:
spec:
  type: ClusterIP
  ports:
    - name: tcp-postgresql
      port: 5432
      targetPort: tcp-postgresql
      nodePort: null
  selector:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/component: read
---
# Source: keycloak/charts/keycloak/templates/headless-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: keycloak-headless
  namespace: default
  labels:
    app.kubernetes.io/name: keycloak
    helm.sh/chart: keycloak-8.0.0
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: keycloak
spec:
  type: ClusterIP
  clusterIP: None
  ports:
    - name: http
      port: 80
      protocol: TCP
      targetPort: http
  publishNotReadyAddresses: true
  selector:
    app.kubernetes.io/name: keycloak
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/component: keycloak
---
# Source: keycloak/charts/keycloak/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: keycloak
  namespace: default
  labels:
    app.kubernetes.io/name: keycloak
    helm.sh/chart: keycloak-8.0.0
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: keycloak
spec:
  type: LoadBalancer
  sessionAffinity: None
  ports:
    - name: http
      port: 80
      protocol: TCP
      targetPort: http
      nodePort: null
    - name: https
      port: 443
      protocol: TCP
      targetPort: https
      nodePort: null
  selector:
    app.kubernetes.io/name: keycloak
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/component: keycloak
---
# Source: keycloak/charts/keycloak/charts/postgresql/templates/primary/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: keycloak-postgresql-primary
  namespace: "default"
  labels:
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-11.1.28
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: primary
  annotations:
spec:
  replicas: 1
  serviceName: keycloak-postgresql-primary-hl
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
  selector:
    matchLabels:
      app.kubernetes.io/name: postgresql
      app.kubernetes.io/instance: keycloak
      app.kubernetes.io/component: primary
  template:
    metadata:
      name: keycloak-postgresql-primary
      labels:
        app.kubernetes.io/name: postgresql
        helm.sh/chart: postgresql-11.1.28
        app.kubernetes.io/instance: keycloak
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/component: primary
      annotations:
    spec:
      serviceAccountName: default
      
      affinity:
        podAffinity:
          
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: postgresql
                    app.kubernetes.io/instance: keycloak
                    app.kubernetes.io/component: primary
                namespaces:
                  - "default"
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:
          
      securityContext:
        fsGroup: 1001
      hostNetwork: false
      hostIPC: false
      initContainers:
      containers:
        - name: postgresql
          image: docker.io/bitnami/postgresql:14.2.0-debian-10-r88
          imagePullPolicy: "IfNotPresent"
          securityContext:
            runAsUser: 1001
          env:
            - name: BITNAMI_DEBUG
              value: "false"
            - name: POSTGRESQL_PORT_NUMBER
              value: "5432"
            - name: POSTGRESQL_VOLUME_DIR
              value: "/bitnami/postgresql"
            - name: PGDATA
              value: "/bitnami/postgresql/data"
            # Authentication
            - name: POSTGRES_USER
              value: "bn_keycloak"
            - name: POSTGRES_POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: keycloak-postgresql
                  key: postgres-password
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: keycloak-postgresql
                  key: password
            - name: POSTGRES_DB
              value: "bitnami_keycloak"
            # Replication
            - name: POSTGRES_REPLICATION_MODE
              value: "master"
            - name: POSTGRES_REPLICATION_USER
              value: "repl_user"
            - name: POSTGRES_REPLICATION_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: keycloak-postgresql
                  key: replication-password
            - name: POSTGRES_CLUSTER_APP_NAME
              value: my_application
            # Initdb
            # Standby
            # LDAP
            - name: POSTGRESQL_ENABLE_LDAP
              value: "no"
            # TLS
            - name: POSTGRESQL_ENABLE_TLS
              value: "no"
            # Audit
            - name: POSTGRESQL_LOG_HOSTNAME
              value: "false"
            - name: POSTGRESQL_LOG_CONNECTIONS
              value: "false"
            - name: POSTGRESQL_LOG_DISCONNECTIONS
              value: "false"
            - name: POSTGRESQL_PGAUDIT_LOG_CATALOG
              value: "off"
            # Others
            - name: POSTGRESQL_CLIENT_MIN_MESSAGES
              value: "warning"
            - name: POSTGRESQL_SHARED_PRELOAD_LIBRARIES
              value: "pgaudit"
          ports:
            - name: tcp-postgresql
              containerPort: 5432
          livenessProbe:
            failureThreshold: 6
            initialDelaySeconds: 30
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            exec:
              command:
                - /bin/sh
                - -c
                - exec pg_isready -U "bn_keycloak" -d "dbname=bitnami_keycloak" -h 127.0.0.1 -p 5432
          readinessProbe:
            failureThreshold: 6
            initialDelaySeconds: 5
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            exec:
              command:
                - /bin/sh
                - -c
                - -e
                
                - |
                  exec pg_isready -U "bn_keycloak" -d "dbname=bitnami_keycloak" -h 127.0.0.1 -p 5432
                  [ -f /opt/bitnami/postgresql/tmp/.initialized ] || [ -f /bitnami/postgresql/.initialized ]
          resources:
            limits: {}
            requests:
              cpu: 250m
              memory: 256Mi
          volumeMounts:
            - name: dshm
              mountPath: /dev/shm
            - name: data
              mountPath: /bitnami/postgresql
      volumes:
        - name: dshm
          emptyDir:
            medium: Memory
        - name: data
          emptyDir:
            medium: Memory

---
# Source: keycloak/charts/keycloak/charts/postgresql/templates/read/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: keycloak-postgresql-read
  namespace: "default"
  labels:
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-11.1.28
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: read
  annotations:
spec:
  replicas: 1
  serviceName: keycloak-postgresql-read-hl
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
  selector:
    matchLabels:
      app.kubernetes.io/name: postgresql
      app.kubernetes.io/instance: keycloak
      app.kubernetes.io/component: read
  template:
    metadata:
      name: keycloak-postgresql-read
      labels:
        app.kubernetes.io/name: postgresql
        helm.sh/chart: postgresql-11.1.28
        app.kubernetes.io/instance: keycloak
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/component: read
      annotations:
    spec:
      serviceAccountName: default
      
      affinity:
        podAffinity:
          
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: postgresql
                    app.kubernetes.io/instance: keycloak
                    app.kubernetes.io/component: read
                namespaces:
                  - "default"
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:
          
      securityContext:
        fsGroup: 1001
      hostNetwork: false
      hostIPC: false
      initContainers:
      containers:
        - name: postgresql
          image: docker.io/bitnami/postgresql:14.2.0-debian-10-r88
          imagePullPolicy: "IfNotPresent"
          securityContext:
            runAsUser: 1001
          env:
            - name: BITNAMI_DEBUG
              value: "false"
            - name: POSTGRESQL_PORT_NUMBER
              value: "5432"
            - name: POSTGRESQL_VOLUME_DIR
              value: "/bitnami/postgresql"
            - name: PGDATA
              value: "/bitnami/postgresql/data"
            # Authentication
            - name: POSTGRES_POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: keycloak-postgresql
                  key: postgres-password
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: keycloak-postgresql
                  key: password
            # Replication
            - name: POSTGRES_REPLICATION_MODE
              value: "slave"
            - name: POSTGRES_REPLICATION_USER
              value: "repl_user"
            - name: POSTGRES_REPLICATION_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: keycloak-postgresql
                  key: replication-password
            - name: POSTGRES_CLUSTER_APP_NAME
              value: my_application
            - name: POSTGRES_MASTER_HOST
              value: keycloak-postgresql-primary
            - name: POSTGRES_MASTER_PORT_NUMBER
              value: "5432"
            # TLS
            - name: POSTGRESQL_ENABLE_TLS
              value: "no"
            # Audit
            - name: POSTGRESQL_LOG_HOSTNAME
              value: "false"
            - name: POSTGRESQL_LOG_CONNECTIONS
              value: "false"
            - name: POSTGRESQL_LOG_DISCONNECTIONS
              value: "false"
            - name: POSTGRESQL_PGAUDIT_LOG_CATALOG
              value: "off"
            # Others
            - name: POSTGRESQL_CLIENT_MIN_MESSAGES
              value: "warning"
            - name: POSTGRESQL_SHARED_PRELOAD_LIBRARIES
              value: "pgaudit"
          ports:
            - name: tcp-postgresql
              containerPort: 5432
          livenessProbe:
            failureThreshold: 6
            initialDelaySeconds: 30
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            exec:
              command:
                - /bin/sh
                - -c
                - exec pg_isready -U "bn_keycloak" -d "dbname=bitnami_keycloak" -h 127.0.0.1 -p 5432
          readinessProbe:
            failureThreshold: 6
            initialDelaySeconds: 5
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            exec:
              command:
                - /bin/sh
                - -c
                - -e
                
                - |
                  exec pg_isready -U "bn_keycloak" -d "dbname=bitnami_keycloak" -h 127.0.0.1 -p 5432
                  [ -f /opt/bitnami/postgresql/tmp/.initialized ] || [ -f /bitnami/postgresql/.initialized ]
          resources:
            limits: {}
            requests:
              cpu: 250m
              memory: 256Mi
          volumeMounts:
            - name: dshm
              mountPath: /dev/shm
            - name: data
              mountPath: /bitnami/postgresql
      volumes:
        - name: dshm
          emptyDir:
            medium: Memory
        - name: data
          emptyDir:
            medium: Memory
---
# Source: keycloak/charts/keycloak/templates/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: keycloak
  namespace: default
  labels:
    app.kubernetes.io/name: keycloak
    helm.sh/chart: keycloak-8.0.0
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: keycloak
spec:
  replicas: 1
  podManagementPolicy: Parallel
  serviceName: keycloak-headless
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
  selector:
    matchLabels: 
      app.kubernetes.io/name: keycloak
      app.kubernetes.io/instance: keycloak
      app.kubernetes.io/component: keycloak
  template:
    metadata:
      annotations:
        checksum/configmap-env-vars: edda1e9e4cbf319d6565941307dabe3555339cb34c363f6b6cbd52c2512fd423
        checksum/secrets: 0865e5f2cf495edc4436daef06db4fd46426fc6e17418be387eb4e0a1e6e87c0
      labels:
        app.kubernetes.io/name: keycloak
        helm.sh/chart: keycloak-8.0.0
        app.kubernetes.io/instance: keycloak
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/component: keycloak
    spec:
      serviceAccountName: keycloak
      
      affinity:
        podAffinity:
          
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: keycloak
                    app.kubernetes.io/instance: keycloak
                namespaces:
                  - "default"
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:
          
      securityContext:
        fsGroup: 1001
      containers:
        - name: keycloak
          image: docker.io/bitnami/keycloak:17.0.1-debian-10-r0
          imagePullPolicy: IfNotPresent
          securityContext:
            runAsNonRoot: true
            runAsUser: 1001
          env:
            - name: KUBERNETES_NAMESPACE
              valueFrom:
                fieldRef:
                  apiVersion: v1
                  fieldPath: metadata.namespace
            - name: BITNAMI_DEBUG
              value: "true"
            - name: KEYCLOAK_ADMIN_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: keycloak
                  key: admin-password
            - name: KEYCLOAK_MANAGEMENT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: keycloak
                  key: management-password
            - name: KEYCLOAK_DATABASE_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: keycloak-postgresql
                  key: password
            - name: KEYCLOAK_PROXY_ADDRESS_FORWARDING
              value: "true"
            - name: KEYCLOAK_LOG_LEVEL
              value: DEBUG
          envFrom:
            - configMapRef:
                name: keycloak-env-vars
          resources:
            limits: {}
            requests: {}
          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
            - name: https
              containerPort: 8443
              protocol: TCP
            - name: http-management
              containerPort: 8080
              protocol: TCP
          livenessProbe:
            failureThreshold: 3
            initialDelaySeconds: 300
            periodSeconds: 1
            successThreshold: 1
            timeoutSeconds: 5
            httpGet:
              path: /
              port: http
          readinessProbe:
            failureThreshold: 3
            initialDelaySeconds: 30
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 1
            httpGet:
              path: /realms/master
              port: http
          volumeMounts:
            - mountPath: /opt/bitnami/keycloak/conf/profile.properties
              name: profiles
              subPath: profile.properties
      volumes:
        - configMap:
            name: keycloak-profile
          name: profiles
---
# Source: keycloak/charts/keycloak/templates/keycloak-config-cli-job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: keycloak-keycloak-config-cli
  namespace: default
  labels:
    app.kubernetes.io/name: keycloak
    helm.sh/chart: keycloak-8.0.0
    app.kubernetes.io/instance: keycloak
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: keycloak-config-cli
  annotations:
    helm.sh/hook: post-install,post-upgrade,post-rollback
    helm.sh/hook-delete-policy: hook-succeeded,before-hook-creation
    helm.sh/hook-weight: "5"
spec:
  backoffLimit: 1
  template:
    metadata:
      labels:
        app.kubernetes.io/name: keycloak
        helm.sh/chart: keycloak-8.0.0
        app.kubernetes.io/instance: keycloak
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/component: keycloak-config-cli
      annotations:
    spec:
      serviceAccountName: keycloak
      
      restartPolicy: Never
      securityContext:
        fsGroup: 1001
      containers:
        - name: keycloak-config-cli
          image: docker.io/bitnami/keycloak-config-cli:5.2.0-debian-10-r3
          imagePullPolicy: IfNotPresent
          command:
            - java
            - -jar
            - /opt/bitnami/keycloak-config-cli/keycloak-config-cli-17.0.1.jar
          securityContext:
            runAsNonRoot: true
            runAsUser: 1001
          env:
            - name: KEYCLOAK_URL
              value: http://keycloak-headless:8080/
            - name: KEYCLOAK_USER
              value: "fiwareAdmin"
            - name: KEYCLOAK_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: keycloak
                  key: admin-password
            - name: IMPORT_PATH
              value: /config/
            - name: KEYCLOAK_AVAILABILITYCHECK_ENABLED
              value: "true"
            - name: IMPORT_FILES_LOCATIONS
              value: /config/*
          volumeMounts:
            - name: config-volume
              mountPath: /config
          resources:
            limits: {}
            requests: {}
      volumes:
        - name: config-volume
          configMap:
            name: keycloak-realm
